前言：

1. 对linux 系统有初步了解，起码用过或者写过一些简单的代码。
2. 知道进程大概是啥东西。
3. 由于进程历史包袱很重，需要支持很多硬件，高速的低速的，个人电脑，服务器。所以里面有很多我们一下子想不到的数据结构和一些功能。

# 进程控制块

无规矩不成方圆。进程也是一样。需要被管理，于是进程控制块`PCB`就出现了。它用于管理一个进程的资源分配，状态，调度等等。

进程控制块对用`struct task_struct`结构体。里面有非常多的结构，我们不需要全部熟悉，只需要知道他是用做拿方面的事情就行。

大致有一下几类：

1. 状态
2. 优先级
3. SMP（多CPU）支持
4. 调度
5. 内存
6. 资源分配
7. 管理
8. 时间
9. IPC
10. 进程间关系
11. debug
12. 文件

> 因为各个类别之间有些关系比较密切就一起说。

1. 当我们运行一个程序的时候，我们需要为其分配`资源`，将程序读到`内存`上，各个进程的内存空间是独立的。
2. 当程序运行在多道批系统上，需要考虑`进程切换（调度）`，有很多调度的算法。不同的算法需要一些额外的数据结构，优先级，实时还是非实时等等。切换的时候要也要切换`状态`。
3. 当我们设置一些定时任务，比如一秒钟打印一次hello，需要有`时间`和`定时器`去管理。
4. 我们还经常需要通信，最基础的就是在shell中执行`ctrl+c`去杀死进程。这其实就是用了`信号`。
5. 当程序运行在大型服务器上，有多个`CPU`。很多新的服务器架构`NUMA`，等等。linux也支持。
6. 为了方便在shell上查看一些进程信息，我们需要`管理`起进程，每个进程有唯一的标识符`PID`以及为了开发人员定位和分析问题。需要支持`debug`。
7. 各个进程之间有些有父子`关系`的。父进程要负责回收子进程，以免出现僵尸进程。
8. linux 底下皆是文件。每个进程都会打开很多文件，也需要对文件进行管理。

    > 各进程fd是独立的。

# 进程状态

- 进程状态
    - 主要状态
        - 执行态
        - 阻塞态
        - 就绪态
    - 其他状态
        - 僵尸态
        - 终止态
        - 创建态

# 进程创建

创建需要用`fork()`。主要讲进程如何涅槃重生。

## 进程clone

#### exec族

exec 函数族的 6 个函数看起来似乎很复杂，但实际上无论是作用还是用法都非常相似，只有很微小的差别。

![](https://secure2.wostatic.cn/static/bEEm88unstWxsWoaUtVBDT/image.png?auth_key=1727609640-g3pqNSPo1eknoSkFgJxU14-0-c691e1dc270d5ac500978ab33e9adb8d)

注：

l(list)：参数地址列表，以空指针结尾。

v(vector)：存有各参数地址的指针数组的地址。

p(path)：按 PATH 环境变量指定的目录搜索可执行文件。

e(environment)：存有环境变量字符串地址的指针数组的地址。

# 进程间通信

> 具体如何使用建议真正用到的时候在细查，因为里面有很多小细节和坑

共享内存

socket

消息队列

管道

信号

需要了解的知识：

- Global TLB和non-global TLB

现代OS都将地址空间分为内核空间和用户空间。内核空间ring 0访问，用户空间ring 3访问。内核空间内容基本各个进程（包括内核线程）都差不多，内核地址空间是一样的，因此对于这部分地址翻译，无论进程如何切换，内核地址空间转换到物理地址的关系是永远不变的，在进程的时候，不需要清掉。对于用户空间，各个进程的内容都不太一样，保留只会造成混乱，需要清掉。

在这种思路引导下，CPU在加载CR3的时候，只会清掉不带Global标志的用户空间页表TLB，而不会动带有global标志的内核页表项。一个新的进程会开始一个半新的TLB，效能提高不少。

- ASID

类似于Global TLB和non-global TLB的思想。有的TLB在每个TLB条目中还保存地址空间标识码（address-space identifier，ASID）。

ASID可用来唯一标识进程，并为进程提供地址空间保护。当TLB试图解析虚拟页号时，它确保当前运行进程的ASID与虚拟页相关的ASID相匹配。如果不匹配，那么就作为TLB失效。

除了提供地址空间保护外，ASID允许TLB同时包含多个进程的条目。如果TLB不支持独立的ASID，每次选择一个页表时（例如，上下文切换时），TLB就必须被冲刷（flushed）或删除，以确保下一个进程不会使用错误的地址转换。

- 原子操作和原语

原子操作（atomic operation）：指不会被[线程调度](https://zhida.zhihu.com/search?content_id=236303268&content_type=Article&match_order=1&q=线程调度&zhida_source=entity)机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch。

原语（primitive or atomic action ）：是由若干条机器指令组成的，用于完成一定功能的一个过程，具有不可分割性。即原语的执行必须是连续的，在执行过程中不允许被中断。

- 进程上下文

一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。

用户级上下文: 正文、数据、用户堆栈以及共享存储区；
寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

- 调度算法
- 虚拟地址切换

除了内核线程（kernel thread），每个进程都拥有自己的地址空间（也叫虚拟空间），用mm_struct来描述。另外Linux2.4还引入了另外一个域active_mm,这是为内核线程而引入。因为内核线程没有自己的地址空间，为了让内核线程与普通进程具有统一的上下文切换方式，当内核线程进行上下文切换时，让切换进来的线程的active_mm指向刚被调度出去的进程的active_mm（如果进程的mm域不为空，则其active_mm域与mm域相同）。

参考：

[Linux PCB(进程控制块) 详解-CSDN博客](https://blog.csdn.net/Dejan520/article/details/123477779)

[深入理解Linux进程原理及实现机制（万字总结） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/666781688)
